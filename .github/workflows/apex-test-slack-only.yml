name: Salesforce Test Runner (Slack Only)

on:
  pull_request:
    types: [opened, synchronize, reopened]
  schedule:
    # Every Monday at 11:00 PM EST (4:00 AM UTC Tuesday)
    - cron: '0 4 * * 2'
  workflow_dispatch:
    inputs:
      test_level:
        description: 'Test Level'
        required: false
        default: 'RunLocalTests'
        type: choice
        options:
          - RunLocalTests
          - RunAllTestsInOrg
          - RunSpecifiedTests

jobs:
  run-salesforce-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Salesforce CLI
        run: |
          npm install -g @salesforce/cli
          sf version

      - name: Authenticate to Salesforce
        run: |
          echo "${{ secrets.SF_AUTH_URL }}" > auth_url.txt
          sf org login sfdx-url --sfdx-url-file auth_url.txt --alias target-org --set-default-dev-hub --set-default
          rm -f auth_url.txt

      - name: Run Tests
        id: run_tests
        run: |
          echo "Running Salesforce tests..."
          TEST_LEVEL="${{ github.event.inputs.test_level || 'RunLocalTests' }}"
          
          # Run tests and capture output
          sf apex run test --test-level $TEST_LEVEL --code-coverage --result-format json --wait 60 --target-org target-org > test_results.json || true
          
          # Parse results
          cat test_results.json
          
          # Extract key metrics
          STATUS=$(jq -r '.result.summary.outcome' test_results.json)
          TOTAL_TESTS=$(jq -r '.result.summary.testsRan' test_results.json)
          PASSED=$(jq -r '.result.summary.passing' test_results.json)
          FAILED=$(jq -r '.result.summary.failing' test_results.json)
          SKIPPED=$(jq -r '.result.summary.skipped' test_results.json)
          CODE_COVERAGE=$(jq -r '.result.summary.testRunCoverage' test_results.json)
          ORG_COVERAGE=$(jq -r '.result.summary.orgWideCoverage' test_results.json)
          EXEC_TIME=$(jq -r '.result.summary.testExecutionTimeInMs' test_results.json)
          
          # Convert execution time to seconds
          EXEC_TIME_SEC=$(echo "scale=2; $EXEC_TIME / 1000" | bc)
          
          # Get failing test classes
          FAILING_TESTS=$(jq -r '.result.tests[] | select(.Outcome == "Fail") | "\(.MethodName) - \(.Message)"' test_results.json | head -10)
          FAILING_CLASSES=$(jq -r '.result.tests[] | select(.Outcome == "Fail") | .ApexClass.Name' test_results.json | sort -u | tr '\n' ', ' | sed 's/,$//')
          
          # Export variables
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "total_tests=$TOTAL_TESTS" >> $GITHUB_OUTPUT
          echo "test_level=$TEST_LEVEL" >> $GITHUB_OUTPUT
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          echo "skipped=$SKIPPED" >> $GITHUB_OUTPUT
          echo "code_coverage=$CODE_COVERAGE" >> $GITHUB_OUTPUT
          echo "org_coverage=$ORG_COVERAGE" >> $GITHUB_OUTPUT
          echo "exec_time=$EXEC_TIME_SEC" >> $GITHUB_OUTPUT
          
          # Save failing tests and classes to file
          echo "$FAILING_TESTS" > failing_tests.txt
          echo "$FAILING_CLASSES" > failing_classes.txt
          
          # Set exit code based on status
          if [ "$STATUS" = "Failed" ]; then
            exit 1
          fi

      - name: Analyze Code Coverage Per Class
        id: coverage_analysis
        if: always()
        run: |
          echo "Analyzing individual class code coverage..."
          COVERAGE_THRESHOLD=95
          
          # Extract individual class coverage
          jq -r '.result.coverage.coverage[] | select(.name != null) | "\(.name)|\(.coveredPercent // 0)"' test_results.json > class_coverage.txt
          
          # Find classes below 95% coverage
          LOW_COVERAGE_CLASSES=""
          LOW_COVERAGE_COUNT=0
          
          while IFS='|' read -r CLASS_NAME COVERAGE_PCT; do
            # Convert coverage to integer for comparison (remove % if present)
            COVERAGE_INT=$(echo "$COVERAGE_PCT" | sed 's/%//' | cut -d'.' -f1)
            
            if [ "$COVERAGE_INT" -lt "$COVERAGE_THRESHOLD" ]; then
              LOW_COVERAGE_CLASSES="${LOW_COVERAGE_CLASSES}${CLASS_NAME}: ${COVERAGE_PCT}%\n"
              LOW_COVERAGE_COUNT=$((LOW_COVERAGE_COUNT + 1))
            fi
          done < class_coverage.txt
          
          # Count total classes
          TOTAL_CLASSES=$(wc -l < class_coverage.txt | tr -d ' ')
          
          # Save low coverage classes to file
          echo -e "$LOW_COVERAGE_CLASSES" > low_coverage_classes.txt
          
          # Export variables
          echo "low_coverage_count=$LOW_COVERAGE_COUNT" >> $GITHUB_OUTPUT
          echo "total_classes=$TOTAL_CLASSES" >> $GITHUB_OUTPUT
          echo "coverage_threshold=$COVERAGE_THRESHOLD" >> $GITHUB_OUTPUT
          
          # Create formatted coverage report
          cat << EOF > coverage_report.md
          ## üìä Code Coverage Analysis (Threshold: ${COVERAGE_THRESHOLD}%)
          
          **Total Classes:** $TOTAL_CLASSES
          **Classes Below ${COVERAGE_THRESHOLD}%:** $LOW_COVERAGE_COUNT
          
          EOF
          
          if [ "$LOW_COVERAGE_COUNT" -gt "0" ]; then
            echo "### ‚ö†Ô∏è Classes Below ${COVERAGE_THRESHOLD}% Coverage" >> coverage_report.md
            echo '```' >> coverage_report.md
            cat low_coverage_classes.txt >> coverage_report.md
            echo '```' >> coverage_report.md
          else
            echo "‚úÖ All classes meet the ${COVERAGE_THRESHOLD}% coverage threshold!" >> coverage_report.md
          fi
          
          # Add top 10 classes with full coverage report
          echo "" >> coverage_report.md
          echo "### üìã Individual Class Coverage" >> coverage_report.md
          echo '```' >> coverage_report.md
          sort -t'|' -k2 -n class_coverage.txt | head -20 | while IFS='|' read -r CLASS_NAME COVERAGE_PCT; do
            echo "${CLASS_NAME}: ${COVERAGE_PCT}%" >> coverage_report.md
          done
          echo '```' >> coverage_report.md
          
          cat coverage_report.md

      - name: Format Test Results for Slack
        id: format_slack
        if: always()
        run: |
          FAILING_CLASSES=$(cat failing_classes.txt || echo "None")
          # Remove trailing comma if present and limit length
          FAILING_CLASSES=$(echo "$FAILING_CLASSES" | sed 's/,$//')
          echo "failing_classes=$FAILING_CLASSES" >> $GITHUB_OUTPUT
          
          # Format low coverage classes for Slack with percentages (limit to 15 for readability)
          if [ -f low_coverage_classes.txt ] && [ -s low_coverage_classes.txt ]; then
            LOW_COVERAGE_CLASSES=$(cat low_coverage_classes.txt | head -15)
          else
            LOW_COVERAGE_CLASSES="None"
          fi
          
          # Store in multiline output
          echo "low_coverage_classes<<EOF" >> $GITHUB_OUTPUT
          echo "$LOW_COVERAGE_CLASSES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Format Test Results for GitHub
        id: format_github
        if: always()
        run: |
          STATUS="${{ steps.run_tests.outputs.status }}"
          
          # Determine emoji based on status
          if [ "$STATUS" = "Passed" ]; then
            EMOJI="‚úÖ"
            COLOR="success"
          else
            EMOJI="‚ùå"
            COLOR="failure"
          fi
          
          # Read failing tests
          FAILING_TESTS=$(cat failing_tests.txt || echo "None")
          
          # Create formatted output
          cat << EOF > github_comment.md
          ## ${EMOJI} Salesforce Test Results
          
          | Metric | Value |
          |--------|-------|
          | **Status** | \`$STATUS\` |
          | **Test Level** | \`${{ steps.run_tests.outputs.test_level }}\` |
          | **Total Tests** | ${{ steps.run_tests.outputs.total_tests }} |
          | **Passed** | ‚úÖ ${{ steps.run_tests.outputs.passed }} |
          | **Failed** | ‚ùå ${{ steps.run_tests.outputs.failed }} |
          | **Skipped** | ‚è≠Ô∏è ${{ steps.run_tests.outputs.skipped }} |
          | **Code Coverage** | ${{ steps.run_tests.outputs.code_coverage }}% |
          | **Org Coverage** | ${{ steps.run_tests.outputs.org_coverage }}% |
          | **Execution Time** | ${{ steps.run_tests.outputs.exec_time }}s |
          
          EOF
          
          if [ "${{ steps.run_tests.outputs.failed }}" != "0" ]; then
            cat << EOF >> github_comment.md
          ### ‚ö†Ô∏è Failing Tests
          \`\`\`
          $FAILING_TESTS
          \`\`\`
          EOF
          fi
          
          # Add coverage analysis
          if [ -f coverage_report.md ]; then
            cat coverage_report.md >> github_comment.md
          fi
          
          cat github_comment.md

      - name: Comment on PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('github_comment.md', 'utf8');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Prepare Slack Payload
        if: always()
        run: |
          # Create the Slack payload
          cat > slack_payload.json << 'SLACKEOF'
          {
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "STATUS_EMOJI Salesforce Test Results"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Status:*\n`TEST_STATUS`"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Test Level:*\n`TEST_LEVEL`"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Total Tests:*\nTOTAL_TESTS"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Passed:*\n‚úÖ PASSED_TESTS"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Failed:*\n‚ùå FAILED_TESTS"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Skipped:*\n‚è≠Ô∏è SKIPPED_TESTS"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Code Coverage:*\nCODE_COVERAGE%"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Org Coverage:*\nORG_COVERAGE%"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Execution Time:*\nEXEC_TIMEs"
                  }
                ]
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Coverage Threshold:*\nCOVERAGE_THRESHOLD%"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Total Classes:*\nTOTAL_CLASSES"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Classes Below COVERAGE_THRESHOLD%:*\nLOW_COVERAGE_COUNT"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Repository:* REPO_NAME\n*Branch:* `BRANCH_NAME`\n*Triggered by:* ACTOR_NAME"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Failed Test Classes:*\nFAILED_CLASSES"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Classes Below 95% Coverage:*\n```LOW_COVERAGE_CLASSES_PLACEHOLDER```"
                }
              },
              {
                "type": "actions",
                "elements": [
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "View Workflow Run"
                    },
                    "url": "WORKFLOW_URL"
                  },
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "üì• Download Test Results"
                    },
                    "url": "ARTIFACTS_URL"
                  }
                ]
              }
            ]
          }
          SLACKEOF
          
          # Replace placeholders
          STATUS_EMOJI="${{ steps.run_tests.outputs.status == 'Passed' && '‚úÖ' || '‚ùå' }}"
          FAILED_CLASSES="${{ steps.run_tests.outputs.failed != '0' && format('`{0}`', steps.format_slack.outputs.failing_classes) || 'None' }}"
          
          sed -i.bak "s/STATUS_EMOJI/$STATUS_EMOJI/g" slack_payload.json
          sed -i.bak "s/TEST_STATUS/${{ steps.run_tests.outputs.status }}/g" slack_payload.json
          sed -i.bak "s/TEST_LEVEL/${{ steps.run_tests.outputs.test_level }}/g" slack_payload.json
          sed -i.bak "s/TOTAL_TESTS/${{ steps.run_tests.outputs.total_tests }}/g" slack_payload.json
          sed -i.bak "s/PASSED_TESTS/${{ steps.run_tests.outputs.passed }}/g" slack_payload.json
          sed -i.bak "s/FAILED_TESTS/${{ steps.run_tests.outputs.failed }}/g" slack_payload.json
          sed -i.bak "s/SKIPPED_TESTS/${{ steps.run_tests.outputs.skipped }}/g" slack_payload.json
          sed -i.bak "s/CODE_COVERAGE/${{ steps.run_tests.outputs.code_coverage }}/g" slack_payload.json
          sed -i.bak "s/ORG_COVERAGE/${{ steps.run_tests.outputs.org_coverage }}/g" slack_payload.json
          sed -i.bak "s/EXEC_TIME/${{ steps.run_tests.outputs.exec_time }}/g" slack_payload.json
          sed -i.bak "s/COVERAGE_THRESHOLD/${{ steps.coverage_analysis.outputs.coverage_threshold }}/g" slack_payload.json
          sed -i.bak "s/TOTAL_CLASSES/${{ steps.coverage_analysis.outputs.total_classes }}/g" slack_payload.json
          sed -i.bak "s/LOW_COVERAGE_COUNT/${{ steps.coverage_analysis.outputs.low_coverage_count }}/g" slack_payload.json
          sed -i.bak "s|REPO_NAME|${{ github.repository }}|g" slack_payload.json
          sed -i.bak "s|BRANCH_NAME|${{ github.head_ref || github.ref_name }}|g" slack_payload.json
          sed -i.bak "s|ACTOR_NAME|${{ github.actor }}|g" slack_payload.json
          sed -i.bak "s|FAILED_CLASSES|${FAILED_CLASSES}|g" slack_payload.json
          sed -i.bak "s|WORKFLOW_URL|${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|g" slack_payload.json
          sed -i.bak "s|ARTIFACTS_URL|${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}#artifacts|g" slack_payload.json
          
          # Handle low coverage classes with proper JSON escaping
          if [ "${{ steps.coverage_analysis.outputs.low_coverage_count }}" != "0" ] && [ -f low_coverage_classes.txt ]; then
            # Read and prepare the low coverage classes text
            # Process line by line to avoid command substitution issues
            LOW_COV_TEXT=$(head -15 low_coverage_classes.txt | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/"/\\"/g' | sed "s/'/\\'/g")
            # Use a temporary marker and then replace
            sed -i.bak "s|LOW_COVERAGE_CLASSES_PLACEHOLDER|${LOW_COV_TEXT}|g" slack_payload.json
          else
            sed -i.bak "s|LOW_COVERAGE_CLASSES_PLACEHOLDER|None - All classes meet the threshold! ‚úÖ|g" slack_payload.json
          fi
          
          cat slack_payload.json

      - name: Send Slack Notification
        if: always()
        run: |
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST \
                 -H "Content-Type: application/json" \
                 -d @slack_payload.json \
                 "${{ secrets.SLACK_WEBHOOK_URL }}"
            echo "‚úÖ Slack notification sent successfully"
          else
            echo "‚ö†Ô∏è SLACK_WEBHOOK_URL secret not configured. Skipping Slack notification."
          fi

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: salesforce-test-results-slack
          path: |
            test_results.json
            class_coverage.txt
            low_coverage_classes.txt
            coverage_report.md
            github_comment.md

      - name: Fail workflow if tests failed
        if: steps.run_tests.outputs.status == 'Failed'
        run: exit 1

