name: Scheduled Salesforce Apex Tests

on:
  # Runs every Monday at 8:00 AM UTC
  schedule:
    - cron: '0 8 * * 1'
  
  # Allows manual triggering for testing
  workflow_dispatch:
    inputs:
      target_org:
        description: 'Target Salesforce Org (default: DevOpsPOC)'
        required: false
        default: 'DevOpsPOC'
      test_level:
        description: 'Test Level (RunLocalTests, RunAllTestsInOrg, etc.)'
        required: false
        default: 'RunLocalTests'

env:
  SF_AUTOUPDATE_DISABLE: true
  SF_USE_GENERIC_UNIX_KEYCHAIN: true
  SF_DOMAIN_RETRY: 300
  SF_LOG_LEVEL: WARN

jobs:
  run-apex-tests:
    name: Run Apex Tests and Report Coverage
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Salesforce CLI
        run: |
          npm install -g @salesforce/cli
          sf version

      - name: Authenticate to Salesforce Org
        env:
          SFDX_AUTH_URL: ${{ secrets.SFDX_AUTH_URL }}
        run: |
          echo "${SFDX_AUTH_URL}" > ./SFDX_AUTH_URL.txt
          sf org login sfdx-url --sfdx-url-file ./SFDX_AUTH_URL.txt --alias DevOpsPOC --set-default
          rm -f ./SFDX_AUTH_URL.txt
          sf org display --target-org DevOpsPOC

      - name: Run Apex Tests
        id: run-tests
        run: |
          echo "Running tests with level: ${{ github.event.inputs.test_level || 'RunLocalTests' }}"
          
          # Run tests ONCE and save JSON output (suppress stderr to avoid warnings in JSON)
          sf apex run test \
            --test-level ${{ github.event.inputs.test_level || 'RunLocalTests' }} \
            --code-coverage \
            --result-format json \
            --output-dir ./test-results \
            --wait 30 \
            --target-org DevOpsPOC 2>/dev/null > test-results.json || true
          
          # Check if we got valid JSON
          if [ ! -s test-results.json ] || ! jq empty test-results.json 2>/dev/null; then
            echo "âš ï¸ First attempt produced invalid JSON, trying without suppressing stderr..."
            sf apex run test \
              --test-level ${{ github.event.inputs.test_level || 'RunLocalTests' }} \
              --code-coverage \
              --result-format json \
              --output-dir ./test-results \
              --wait 30 \
              --target-org DevOpsPOC > test-results.json 2>&1 || true
          fi
          
          # Display results in human-readable format
          echo ""
          echo "=== Test Results ==="
          if [ -f "test-results.json" ] && jq empty test-results.json 2>/dev/null; then
            jq -r '.summary | "Tests Ran: \(.testsRan // 0)\nPassing: \(.passing // 0)\nFailing: \(.failing // 0)\nSkipped: \(.skipped // 0)\nCode Coverage: \(.testRunCoverage // "N/A")\nOrg Coverage: \(.orgWideCoverage // "N/A")\nOutcome: \(.outcome // "Unknown")"' test-results.json || cat test-results.json | head -50
          else
            echo "âŒ No valid test results available"
            cat test-results.json 2>/dev/null || echo "No JSON file found"
          fi

      - name: Parse Test Results
        id: parse-results
        run: |
          # Install jq for JSON parsing
          sudo apt-get update && sudo apt-get install -y jq
          
          # Parse JSON results
          if [ -f "test-results.json" ]; then
            # Check if the file contains valid JSON
            if jq empty test-results.json 2>/dev/null; then
              # Extract summary information
              TOTAL_TESTS=$(jq -r '.summary.testsRan // 0' test-results.json 2>/dev/null || echo "0")
              PASSED_TESTS=$(jq -r '.summary.passing // 0' test-results.json 2>/dev/null || echo "0")
              FAILED_TESTS=$(jq -r '.summary.failing // 0' test-results.json 2>/dev/null || echo "0")
              SKIPPED_TESTS=$(jq -r '.summary.skipped // 0' test-results.json 2>/dev/null || echo "0")
              
              # Code coverage - handle both percentage and decimal formats
              COVERAGE=$(jq -r '.summary.testRunCoverage // "0%"' test-results.json 2>/dev/null || echo "0%")
              
              # Extract org coverage percentage if available
              ORG_COVERAGE=$(jq -r '.summary.orgWideCoverage // "N/A"' test-results.json 2>/dev/null || echo "N/A")
              
              # Test run time
              TEST_TIME=$(jq -r '.summary.testExecutionTime // "N/A"' test-results.json 2>/dev/null || echo "N/A")
              
              # Outcome
              OUTCOME=$(jq -r '.summary.outcome // "Unknown"' test-results.json 2>/dev/null || echo "Unknown")
            else
              echo "âš ï¸ test-results.json contains invalid JSON"
              echo "JSON content:"
              cat test-results.json
              
              # Set default values
              TOTAL_TESTS="0"
              PASSED_TESTS="0"
              FAILED_TESTS="0"
              SKIPPED_TESTS="0"
              COVERAGE="0%"
              ORG_COVERAGE="N/A"
              TEST_TIME="N/A"
              OUTCOME="Failed"
            fi
            
            echo "total_tests=${TOTAL_TESTS}" >> $GITHUB_OUTPUT
            echo "passed_tests=${PASSED_TESTS}" >> $GITHUB_OUTPUT
            echo "failed_tests=${FAILED_TESTS}" >> $GITHUB_OUTPUT
            echo "skipped_tests=${SKIPPED_TESTS}" >> $GITHUB_OUTPUT
            echo "coverage=${COVERAGE}" >> $GITHUB_OUTPUT
            echo "org_coverage=${ORG_COVERAGE}" >> $GITHUB_OUTPUT
            echo "test_time=${TEST_TIME}" >> $GITHUB_OUTPUT
            echo "outcome=${OUTCOME}" >> $GITHUB_OUTPUT
            
            echo "ðŸ“Š Test Summary:"
            echo "Total Tests: ${TOTAL_TESTS}"
            echo "Passed: ${PASSED_TESTS}"
            echo "Failed: ${FAILED_TESTS}"
            echo "Skipped: ${SKIPPED_TESTS}"
            echo "Code Coverage: ${COVERAGE}"
            echo "Org-Wide Coverage: ${ORG_COVERAGE}"
            echo "Outcome: ${OUTCOME}"
          else
            echo "âŒ Test results file not found"
            echo "outcome=Failed" >> $GITHUB_OUTPUT
            echo "total_tests=0" >> $GITHUB_OUTPUT
            echo "passed_tests=0" >> $GITHUB_OUTPUT
            echo "failed_tests=0" >> $GITHUB_OUTPUT
            echo "skipped_tests=0" >> $GITHUB_OUTPUT
            echo "coverage=0%" >> $GITHUB_OUTPUT
            echo "org_coverage=N/A" >> $GITHUB_OUTPUT
            echo "test_time=N/A" >> $GITHUB_OUTPUT
          fi

      - name: Generate Coverage Report
        id: coverage-report
        if: always()
        run: |
          # Create a detailed coverage report
          if [ -f "test-results.json" ]; then
            echo "## ðŸ“ˆ Code Coverage Details" > coverage-report.md
            echo "" >> coverage-report.md
            
            # Check if coverage data exists
            HAS_COVERAGE=$(jq -r '.coverage // empty' test-results.json)
            
            if [ ! -z "$HAS_COVERAGE" ]; then
              echo "| Class Name | Coverage % | Lines Covered | Lines Uncovered |" >> coverage-report.md
              echo "|------------|-----------|---------------|-----------------|" >> coverage-report.md
              
              # Extract coverage per class
              jq -r '.coverage.coverage[] | "| \(.name) | \(.coveredPercent)% | \(.numLocations - .numLocationsNotCovered) | \(.numLocationsNotCovered) |"' test-results.json >> coverage-report.md 2>/dev/null || echo "| No coverage data available | - | - | - |" >> coverage-report.md
            else
              echo "No detailed coverage data available in test results." >> coverage-report.md
            fi
            
            cat coverage-report.md
          else
            echo "No coverage report available" > coverage-report.md
          fi

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: apex-test-results
          path: |
            test-results.json
            coverage-report.md
            ./test-results/**/*
          retention-days: 30

      - name: Send Slack Notification
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          OUTCOME: ${{ steps.parse-results.outputs.outcome }}
          TOTAL_TESTS: ${{ steps.parse-results.outputs.total_tests }}
          PASSED_TESTS: ${{ steps.parse-results.outputs.passed_tests }}
          FAILED_TESTS: ${{ steps.parse-results.outputs.failed_tests }}
          SKIPPED_TESTS: ${{ steps.parse-results.outputs.skipped_tests }}
          COVERAGE: ${{ steps.parse-results.outputs.coverage }}
          ORG_COVERAGE: ${{ steps.parse-results.outputs.org_coverage }}
          TEST_TIME: ${{ steps.parse-results.outputs.test_time }}
        run: |
          # Set default values if empty
          OUTCOME="${OUTCOME:-Unknown}"
          TOTAL_TESTS="${TOTAL_TESTS:-0}"
          PASSED_TESTS="${PASSED_TESTS:-0}"
          FAILED_TESTS="${FAILED_TESTS:-0}"
          SKIPPED_TESTS="${SKIPPED_TESTS:-0}"
          COVERAGE="${COVERAGE:-0%}"
          ORG_COVERAGE="${ORG_COVERAGE:-N/A}"
          TEST_TIME="${TEST_TIME:-N/A}"
          
          echo "Test Results: $TOTAL_TESTS tests, $PASSED_TESTS passed, $FAILED_TESTS failed"
          echo "Coverage: $COVERAGE, Org Coverage: $ORG_COVERAGE"
          echo "Outcome: $OUTCOME"
          
          # Determine color based on outcome
          if [ "$OUTCOME" == "Passed" ]; then
            COLOR="#36a64f"  # Green
            EMOJI=":white_check_mark:"
          else
            COLOR="#ff0000"  # Red
            EMOJI=":x:"
          fi
          
          # Extract failed test details
          FAILED_TESTS_LIST=""
          if [ -f "test-results.json" ] && [ "$FAILED_TESTS" != "0" ] && [ "$FAILED_TESTS" != "" ]; then
            echo "Extracting failed test details..."
            FAILED_TESTS_LIST=$(jq -r '
              .tests[]? 
              | select(.Outcome == "Fail") 
              | "â€¢ *" + (.ApexClass.Name // .FullName // "Unknown") + "." + (.MethodName // "unknown") + "*\n  `" + (.Message // "No message" | split("\n")[0] | .[0:120]) + "`"
            ' test-results.json 2>/dev/null | head -10 || echo "")
          fi
          
          # Extract top 10 classes with lowest coverage
          LOW_COVERAGE_CLASSES=""
          if [ -f "test-results.json" ]; then
            echo "Extracting low coverage classes..."
            LOW_COVERAGE_CLASSES=$(jq -r '
              .coverage.coverage[]? 
              | select(.coveredPercent < 75) 
              | "â€¢ *" + .name + "*: " + (.coveredPercent | tostring) + "% (" + ((.numLocations - .numLocationsNotCovered) | tostring) + "/" + (.numLocations | tostring) + " lines)"
            ' test-results.json 2>/dev/null | sort -t':' -k2 -n | head -10 || echo "")
          fi
          
          # Extract top covered classes  
          TOP_COVERAGE_CLASSES=""
          if [ -f "test-results.json" ]; then
            echo "Extracting top coverage classes..."
            TOP_COVERAGE_CLASSES=$(jq -r '
              .coverage.coverage[]? 
              | select(.coveredPercent >= 90) 
              | "â€¢ *" + .name + "*: " + (.coveredPercent | tostring) + "%"
            ' test-results.json 2>/dev/null | sort -t':' -k2 -rn | head -5 || echo "")
          fi
          
          # Build Slack message payload with rich formatting
          SLACK_PAYLOAD=$(cat <<EOF
          {
            "username": "Salesforce Test Bot",
            "icon_emoji": ":salesforce:",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "${EMOJI} Salesforce Apex Tests - DevOpsPOC Org"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Full Results on GitHub>"
                }
              },
              {
                "type": "section",
                "fields": [
                  {"type": "mrkdwn", "text": "*Status:*\n${OUTCOME}"},
                  {"type": "mrkdwn", "text": "*Test Level:*\nRunLocalTests"},
                  {"type": "mrkdwn", "text": "*Total Tests:*\n${TOTAL_TESTS}"},
                  {"type": "mrkdwn", "text": "*Passed:*\n:white_check_mark: ${PASSED_TESTS}"},
                  {"type": "mrkdwn", "text": "*Failed:*\n:x: ${FAILED_TESTS}"},
                  {"type": "mrkdwn", "text": "*Skipped:*\n${SKIPPED_TESTS}"},
                  {"type": "mrkdwn", "text": "*Code Coverage:*\n:bar_chart: ${COVERAGE}"},
                  {"type": "mrkdwn", "text": "*Org Coverage:*\n:chart_with_upwards_trend: ${ORG_COVERAGE}"},
                  {"type": "mrkdwn", "text": "*Execution Time:*\n:stopwatch: ${TEST_TIME}"},
                  {"type": "mrkdwn", "text": "*Triggered By:*\n${{ github.actor }}"}
                ]
              },
              {
                "type": "divider"
              }
            ],
            "attachments": []
          }
          EOF
          )
          
          # Add failed tests section if there are failures
          if [ ! -z "$FAILED_TESTS_LIST" ]; then
            # Escape the failed tests for JSON
            FAILED_TESTS_ESCAPED=$(echo "$FAILED_TESTS_LIST" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
            
            # Build the failed tests blocks
            FAILED_BLOCKS=',{"type":"section","text":{"type":"mrkdwn","text":":rotating_light: *Failed Tests:*"}},{"type":"section","text":{"type":"mrkdwn","text":"'"$FAILED_TESTS_ESCAPED"'"}}'
            
            # Insert into payload
            SLACK_PAYLOAD=$(echo "$SLACK_PAYLOAD" | sed 's/"attachments": \[\]/"blocks_failed_insert", "attachments": []/')
            SLACK_PAYLOAD="${SLACK_PAYLOAD//\"blocks_failed_insert\"/$FAILED_BLOCKS}"
          fi
          
          # Add coverage details section
          if [ ! -z "$LOW_COVERAGE_CLASSES" ] || [ ! -z "$TOP_COVERAGE_CLASSES" ]; then
            # Escape coverage data for JSON
            TOP_ESCAPED=$(echo "$TOP_COVERAGE_CLASSES" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
            LOW_ESCAPED=$(echo "$LOW_COVERAGE_CLASSES" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
            
            # Start coverage section
            COVERAGE_BLOCKS=',{"type":"divider"},{"type":"section","text":{"type":"mrkdwn","text":":bar_chart: *Code Coverage Details*"}}'
            
            # Add top coverage if available
            if [ ! -z "$TOP_COVERAGE_CLASSES" ]; then
              COVERAGE_BLOCKS="$COVERAGE_BLOCKS"',{"type":"section","text":{"type":"mrkdwn","text":":trophy: *Top Coverage (â‰¥90%):*\\n'"$TOP_ESCAPED"'"}}'
            fi
            
            # Add low coverage if available
            if [ ! -z "$LOW_COVERAGE_CLASSES" ]; then
              COVERAGE_BLOCKS="$COVERAGE_BLOCKS"',{"type":"section","text":{"type":"mrkdwn","text":":warning: *Needs Improvement (<75%):*\\n'"$LOW_ESCAPED"'"}}'
            fi
            
            # Insert coverage section
            SLACK_PAYLOAD=$(echo "$SLACK_PAYLOAD" | sed 's/"attachments": \[\]/"blocks_coverage_insert", "attachments": []/')
            SLACK_PAYLOAD="${SLACK_PAYLOAD//\"blocks_coverage_insert\"/$COVERAGE_BLOCKS}"
          fi
          
          # Add timestamp footer
          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
          FOOTER_BLOCKS=',{"type":"context","elements":[{"type":"mrkdwn","text":":github: GitHub Actions | '"$TIMESTAMP"'"}]}'
          
          SLACK_PAYLOAD=$(echo "$SLACK_PAYLOAD" | sed 's/"attachments": \[\]/"blocks_footer_insert", "attachments": []/')
          SLACK_PAYLOAD="${SLACK_PAYLOAD//\"blocks_footer_insert\"/$FOOTER_BLOCKS}"
          
          # Send to Slack
          if [ -n "${SLACK_WEBHOOK_URL}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "${SLACK_PAYLOAD}" \
              "${SLACK_WEBHOOK_URL}"
            echo "âœ… Slack notification sent successfully"
          else
            echo "âš ï¸  SLACK_WEBHOOK_URL secret not configured. Skipping Slack notification."
          fi

      - name: Fail if tests failed
        if: steps.parse-results.outputs.outcome != 'Passed'
        run: |
          echo "âŒ Test run failed with outcome: ${{ steps.parse-results.outputs.outcome }}"
          exit 1


